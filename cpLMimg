#!/usr/bin/perl -w
use warnings;
use strict;
use Getopt::Long;
use File::Copy;
use File::Path qw(make_path);

my $thisisme = "cpLMimages";

## setup defaults
my $dest_root = "./";
my $source_root = "/cygdrive/l/";
my $filemode = 1;
my $dirmode = 0;
my $logfile = "/tmp/$thisisme.log." . mytimestamp() . ".txt";
my $verbose = "true";
my $silent = "";
my $dbg = "";

## other variables we need
my ($dest_path, $root_rem, $srcdir, $srcdir_esc, $curfile_fullpath,
    $tmp1, $tmp2, $showhelp);
my @files = {};
my $numcopies = 0;
my $usage = <<END;

$thisisme : Copy Lexmark Image files from the Lexmark server to a destination

usage: $thisisme [OPTIONS] FILE(s)

OPTIONS:
    -f                      file mode (defualt) - FILE contains a
                            list of full paths to image file names
                            to copy

    -d                      directory mode - FILE contains lists of
                            directories rather than full paths to
                            image files; will copy only the .tif
                            files from these directories
                            
    --rem <root_rem>        <root_rem> is the portion of the source
                            directory path to remove from the
                            beginning of each directory in the
                            listing;
                            (defaults to blank)

    --src <src_root>        <src_root> is the root directory of the
                            image path accessable from this
                            environment; this is prepended to each
                            directory processed
                            (defaults to $source_root)

    --dest <dest_root>      <dest_root> is the destination root path
                            where the files will be copied;
                            (defaults to current directory)

FILE(s)
    in default (file) mode:
            one or more files with a list of imagefile names with
            a full path; this could be a direct output from
            the database, e.g. "
            select unique imagepath from ACI.BENCHMARK
            where test_id like '2010-12%'"

    in directory mode:    
            one or more files with a list of directories with
            images to be copied

END

##
## check for arguments
##
if ($#ARGV == -1) {
    print STDERR $usage;
    exit -1;
}

##
## read in the switches if there are any
##
GetOptions ('f' => \$filemode,
            'd' => \$dirmode,
            'src:s' => \$tmp1,
            'dest:s' => \$tmp2,
            'rem:s' => \$root_rem,
            'help|h|?' => \$showhelp,
            'silent' => \$silent,
            'debug' => \$dbg);

if ($dirmode) {
    $filemode = 0;
}
if ($showhelp) {
    print STDERR $usage;
    exit -1;
}
if ($tmp1) {
    $source_root = fixpathname($tmp1);
}
if ($tmp2) {
    $dest_root = fixpathname($tmp2);
}
fixpathname(undslash($root_rem));
if ($dbg) {
    print "root rem:    $root_rem\n";  
    print "source root: $source_root\n";
    print "dest root:   $dest_root\n\n";
}

##
## setup logfile
##
open LOGFILE, ">$logfile" or die $!;
unless ($silent) {print STDERR "writing logs to $logfile\n";}
        
##
## read through the directory list
##

unless ($silent) {print STDERR "copying files:\n";}
while (<>) {
        ## do root_remove and source_root replacements on current item
        mychomp($_);                    # remove newline / CR
        undslash($_);                   # fix double slashes
        if ($dbg) {print "----- dol _ before = $_\n";}
        pathsubbeg($_, $root_rem, $source_root);       
        if ($dbg) {print "----- dol _ after = $_\n";}

        # set the source
        $srcdir = $_;
        if ($dbg) {print "+++++ source:\n $srcdir\n";}
        
    if ($filemode) {    ## running in filemode - get the file
        $srcdir = getjustpath($_);
        @files = $_;
    }

    else {              ## get list of files from directory
        ## get list of tif files in source directory
        fixpathname($srcdir);       #add trailing slash if needed
        $srcdir_esc = escapifypath($srcdir);
        @files = <$srcdir_esc*.tif>;
        if ($dbg) { print "+++++ num files = " . @files . "\n"; }
    }
    
    
    ## copy each file to destination
    foreach $curfile_fullpath (@files) {
        fixLMfilename($curfile_fullpath);        
        
        if ($dbg) {print "+++++ curfile_fullpath: $curfile_fullpath\n";}
        # define the destination path
        $dest_path = pathsubbeg($srcdir, $source_root, $dest_root);
        fixLMfilename($dest_path);
        if ($dbg) {print "+++++ dest path: $dest_path\n";}
        
        # create dest directory if needed
        if ($dbg) {print "++make path $dest_path\n";}
        make_path($dest_path);
        
        # copy the file        
        writelog("+copying $curfile_fullpath to $dest_path");
        copy ($curfile_fullpath, $dest_path) or die <<END;
        
**** unable to copy file:
     $curfile_fullpath
     to
     $dest_path
     
     $!
****
END
        $numcopies++;
        unless ($silent) {
            print STDERR "+";
            if (($numcopies > 0) && ($numcopies % 50 == 0)) {
                print STDERR "\n";
            }
        }
    }
}

unless ($silent) {
    print STDERR "\n\n**** copied $numcopies file" .
                (($numcopies > 1) ? "s\n" : "\n");}
writelog("\n\n**** copied $numcopies file" . (($numcopies > 1) ? "s" : " "));

close LOGFILE;

exit 1;

#########################################
##### functions
#########################################

#####
## escapifypath - add escape charaters to a path if there are
##      any spaces, plus some other stuff
#####
sub escapifypath
{
    my $work = $_[0];
  
    ## replace single spaces
    $work =~ s/ /\\ /g;
    
    ## escape parens
    $work =~ s{\(}{\\(}g;
    $work =~ s{\)}{\\)}g;
    
    ## escape commas
    $work =~ s/,/\\,/g;
        
    return $work;
}

#####
## unescapifypath - remove escape characters from a path
#####
sub unescapifypath
{
    my $work = $_[0];
  
    ## unescape single spaces
    $work =~ s/\\ / /g;
    
    ## unescape parens
    $work =~ s{\\\(}{\(}g;
    $work =~ s{\\\)}{\)}g;
    
    ## unescape commas
    $work =~ s/\\,/,/g;
        
    return $work;
    
}


#####
## mychomp - remove CR and/or LF / NL; not sure why chomp
##      doesn't work here, maybe something to do with stupid Windows?
#####
sub mychomp
{
    $_[0] =~ s/[\n\r]+//;
    return $_[0];
}

#####
## undslash - changes double slashes ("//") to single ("/")
#####
sub undslash
{
    $_[0] =~ s{[\/]{2}}{\/}g;
    
    return $_[0];
}

#####
## fixpathname - adds a / to the end of a pathname if necessary
#####
sub fixpathname
{
    # add a slash to the end of the path if one isn't there
    $_[0] =~ s{^(.*)([^\/])$}{$1$2\/};
    
    return $_[0];
}

#####
## writelog - write a log message to the logfile
#####
sub writelog
{
    print LOGFILE "$_[0]\n\n";
    
    return 1;
}


#####
## mytimestamp - returns a string with a nice timestamp in
##      the format YYYYMMDDHHMMSS
#####
sub mytimestamp
{
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst);
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                localtime(time);
    
    $year += 1900;
    $mon++;
    my $dmon = sprintf("%02d", $mon);
    my $dmday = sprintf("%02d", $mday);
    my $dhour = sprintf("%02d", $hour);
    my $dmin = sprintf("%02d", $min);
    my $dsec = sprintf("%02d", $sec);
    return $year . $dmon . $dmday . $dhour . $dmin . $dsec;
}

#####
## fixLMfilename - fixes the filename taken from the database
##      that Lexmark writes to; a few things are weird, so
##      we're going to be very nice and fix them
#####
sub fixLMfilename
{
    ## add a comma if necessary
    $_[0] =~ s{(\/[A-Z]+)  ([A-Z]+ - )}{$1, $2};
    
    ## add a comma even if the double spaces are escaped
    $_[0] =~ s{(\/[A-Z]+)\\ \\ ([A-Z]+\\ -\\ )}{$1\\,\\ $2};
    
    ## change "scans__" to "scans_"
    $_[0] =~ s/scans__/scans_/;
 
    ## fix problem of missing parens in tif filename
    $_[0] =~ s/([0-9]+) ([0-9]) (\.tif)$/$1\($2\)$3/;
    return $_[0];
}

#####
## getjustpath - returns just the path for the specified full-path
##      filename
#####
sub getjustpath
{
    if ($_[0] =~ /^(.*\/)([^\/]+)$/) {
        return $1;
    }

    return $_[0];
}

#####
## pathsubbeg - in the full path $_[0], removes $_[1] from
##      the beginning, and adds (effectively substituting)
##      $_[2]; note that $_[2] is optional
#####
sub pathsubbeg
{
    ## escape the meta characters in the paths
    my $remove_esc = escapifypath($_[1]);
    my $replace_esc = ($_[2] ? escapifypath($_[2]) : "");
    
    $_[0] =~ s{^($remove_esc)}{$replace_esc};
    $_[0] = unescapifypath($_[0]);
    
    return $_[0]; 
}